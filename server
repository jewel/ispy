#!/usr/bin/ruby

require 'sinatra'
require 'json'

set :server, :thin
set :port, 8111
set :bind, ""
set :logging, false

images = {}
message_queue = {}
connections = []

put '/update/:name' do
  name = params[:name]
  return "no thanks" if name =~ /\Agdm@/
  images[ name ] = {
    time: Time.new,
    image: request.body.read,
  }

  # Check if there's a pending action for this user
  response_data = {}
  if message_queue[name] && !message_queue[name].empty?
    response_data = message_queue[name].shift
  end

  Thread.new do
    recent = images.keys.select do |k|
      v = images[k]
      v[:time] + 5 > Time.new
    end
    recent.map! do |k|
      v = images[k]
      [k, (v[:time].to_f * 1000).round]
    end
    connections.each do |out|
      out << "event: update\n"
      out << "data: #{recent.to_json}\n\n"
    end
  end

  content_type "application/json"
  response_data.to_json
end

# Admin endpoints for sending messages and suspensions
post '/admin/message' do
  begin
    data = JSON.parse(request.body.read)
    target = data['target']  # 'all' or specific username@hostname
    message = data['message']

    if target == 'all'
      # Only send to recently active computers (within last 5 seconds)
      recent_computers = images.keys.select do |name|
        next false if name =~ /\Agdm@/
        v = images[name]
        v[:time] + 5 > Time.new
      end

      recent_computers.each do |name|
        message_queue[name] ||= []
        message_queue[name] << { 'message' => message }
      end
    else
      message_queue[target] ||= []
      message_queue[target] << { 'message' => message }
    end

    "ok"
  rescue JSON::ParserError
    status 400
    "Invalid JSON"
  rescue => e
    status 500
    "Error: #{e.message}"
  end
end

post '/admin/suspend' do
  begin
    data = JSON.parse(request.body.read)
    target = data['target']  # 'all' or specific username@hostname

    if target == 'all'
      # Only send to recently active computers (within last 5 seconds)
      recent_computers = images.keys.select do |name|
        next false if name =~ /\Agdm@/
        v = images[name]
        v[:time] + 5 > Time.new
      end

      recent_computers.each do |name|
        message_queue[name] ||= []
        message_queue[name] << { 'suspend' => true }
      end
    else
      message_queue[target] ||= []
      message_queue[target] << { 'suspend' => true }
    end

    "ok"
  rescue JSON::ParserError
    status 400
    "Invalid JSON"
  rescue => e
    status 500
    "Error: #{e.message}"
  end
end

# When the last user disconnects, make sure that an empty update goes out
Thread.new do
  loop do
    sleep 5
    recent = images.keys.select do |k|
      v = images[k]
      v[:time] + 5 > Time.new
    end
    next if recent.size > 0
    connections.each do |out|
      out << "event: update\n"
      out << "data: #{recent.to_json}\n\n"
    end
  end
end

get '/' do
  erb :index
end

get '/view/:name' do
  content_type "image/jpeg"
  images[ params[:name] ][:image]
end

get '/subscribe' do
  content_type 'text/event-stream'
  stream(:keep_open) do |out|
    connections << out
    out.callback { connections.delete out }
  end
end

get '/active' do
  recent = images.keys.select do |k|
    v = images[k]
    v[:time] + 5 > Time.new
  end
  if recent.size > 0
    "running\n"
  else
    "suspend\n"
  end
end
